<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="txtHelp.Text" xml:space="preserve">
    <value>
STEPS TO SOLVING A RUBIK'S CUBE:
------------------------------------------------------------------------------------------------------------------------------------------
1) SOLVE THE WHITE CROSS. After a bit of practice, you should be able to make a white cross intuitively. Make sure that your white edge pieces (only have two colors, white and some other color) also match up with the center color of the side they share. NOTE: Center pieces (only one color) never move. This is how you know which side is which.

2) SOLVE THE WHITE CORNERS. There are three algorithms which may be of use to you here. To use these algorithms, first position the cube so that the white cross is on the bottom side and the corner piece you want to relocate is at the front-right corner of the top side. NOTE: The white sticker on the piece you want to relocate will be on one of either of three sides: front, right, top.

R U R’ - When the white sticker is on the right side.
F’ U’ F - When the white sticker is on the front side.
R U2 R’ U’ R U R’ - When the white sticker is on the top side.

3) SOLVE THE MIDDLE EDGES. Remember, edge pieces only have two colors. Position the edge piece you want to use on the top-right side of the cube. The white side should still be facing the bottom. The edge piece you want to relocate should also have a matching right side color as the center piece of the right side. Then, depending on if you want to relocate the piece to the front or the back, you have two different algorithms to choose from.

R’ U’ R’ U’ R’ U R U R - When you want to move the edge piece to the front.
R U R U R U’ R’ U’ R’ - When you want to move the edge piece to the back.

4) SOLVE THE YELLOW CROSS. The yellow side is always directly opposite the white side (remember, the center pieces never move). Once again, there are two algorithms to choose from to get a yellow cross on the top side. If neither of the conditions are met, choose either of the algorithms. Keep repeating the algorithms until you have a yellow cross. NOTE: A lowercase turn letter signals you to turn the center/middle side in addition to the side represented by the turn letter. This will turn two-thirds of the cube at once.

F R U R’ U’ F’ - When you already have a yellow line (three yellow stickers in a row).
F R U R’ U’ f’ - When you have a yellow elbow (three yellow stickers not in a row).

5) SOLVE THE YELLOW CORNERS. Once you have a yellow cross completed, you will have either one, two, or zero yellow corners in position with the yellow sticker on the yellow side. There is only one algorithm for this step, but the number of yellow stickers you start out with will determine the position of the cube before you complete the algorithm. NOTE: If you have one yellow sticker in position, turn the cube so that the yellow side is the upward side and the single yellow sticker is in the front-left corner before you complete the algorithm. For two yellow stickers in position, turn the cube until you have a yellow sticker on the front-left side (the yellow sticker itself should not be on the upward, yellow side). For zero yellow stickers, follow the instructions as if you have two yellow stickers, but this time the yellow sticker itself should be on the left side in the front-left corner.

R U R’ U R U2 R’

6) BEGIN TO SOLVE THE TOP EDGES. If your top edges are all messed up, then you will have to complete the following algorithm until they are in a more manageable state. The more manageable state refers to all four edges having a combination of solid lines and/or headlights, which is when the two corner edge pieces have the same colors but the middle edge piece is different.

R’ F R’ B2 R F’ R’ B2 R2

7) COMPLETE THE TOP EDGES. Once your top edges are in a more manageable state, as defined in step 6, you may keep doing the following algorithm until your cube is completely solved.

R U’ R U R U R U’ R’ U’ R2
------------------------------------------------------------------------------------------------------------------------------------------

CONGRATULATIONS, YOU ARE FINISHED!</value>
  </data>
</root>